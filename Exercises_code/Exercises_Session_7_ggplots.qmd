---
title: "Exercises Session 7:  ggplot2"
author:
  name: Guillem Ylla, PhD
  affiliations:
    id: JU
    name: Jagiellonian University
format: 
  html:
      number-sections: false
      #number-depth: 3
      embed-resources: true
      theme: lumen
      toc: true
      toc-location: left
      toc-depth: 6
      toc-expand: true
      code-tools:
        source: true
        toggle: true
      code-fold: true
      code-summary: "Show the code"
      code-overflow: wrap
      page-layout: full
editor: visual
editor_options: 
  markdown: 
    wrap: 72
---

```{r}
#| code-fold: true
#| output: false

knitr::opts_chunk$set(echo = TRUE)
library("tidyr")
library("dplyr")
library("ggplot2")
```

## 

### Load and transform data

Let's read a TPMs table that we used in the past weeks. Remember that
for each gene we have normalized counts in TPMs (\~ relative expression)
in 4 different samples. This means that we have **continuous data (TPMs)
grouped by categories (genes, and samples)** .

```{r}
#| output: false
Table_TPMs_wide<-readr::read_csv("data/TPMs_table_100genes.csv")
```

Let's make it to long format with the **`tidyr`** function
`pivot_longer()`.

```{r}
Table_TPMs_long<-pivot_longer(data=Table_TPMs_wide, 
                             cols=colnames(Table_TPMs_wide)[-1],# Cols to pivot: all except 1st
                             values_to = "TPMs",# name of the col that contained the vals of pivoted cols
                             names_to = "Sample")# name of the col that contains the names of the pivoted cols

Table_TPMs_long
```

Now that we have in long format, we can split the Sample column into new
columns with the Condition and replicate number.

```{r}
Table_TPMs_long_2<-Table_TPMs_long %>% 
                        tidyr::separate(Sample, sep="_", into = c("Condition","Replicate"),remove=FALSE)

Table_TPMs_long_2 
```

## First steps with ggplots

Initialize the plot, with the data, and the mapping of X and Y
variables.

```{r}
p<-ggplot(data = Table_TPMs_long_2, aes(x=Sample, y=TPMs))

p
```

### Scatter plot

Let's make a scatter plot. For each sample, we want to see the
expression of each gene as a dot:

```{r}
p+geom_point()

```

We can spread the points horizontally to reduce overlaps.

```{r}
p+geom_point( position = position_jitter()) 
```

### Boxplot

`geom_` functions can perform calculations. For example, they can
calculate the median, quartiles, and everything necessary o plot a
boxplot using `geom_boxplot`.

```{r}
ggplot(data = Table_TPMs_long_2, aes(x=Sample, y=TPMs))+
  geom_boxplot()
```

Inside the `geom_` function, we can also determine colors and shapes.

```{r}
ggplot(data = Table_TPMs_long_2, aes(x=Sample, y=TPMs))+
  geom_boxplot(outlier.colour ="darkred")
```

-   We can now fill boxes based on condition, fort which we need to
    **map** variable Condition to filling color with `aes()`.

    -   Note that options outside `aes()` are global to the layer, and
        inside `aes()` are mapped to data.

```{r}
ggplot(data = Table_TPMs_long_2, aes(x=Sample, y=TPMs))+
  geom_boxplot(outlier.colour ="darkred", aes(fill=Condition))
```

#### Exercise 1 {style="background-color: #fafaa0"}

Use the Table_TPMs_long_2 to make a **violin plot**, in which the boxes
are filled based on the replicate number (1, 2, or 3), and the border
color is darkblue for all of them.

```{r}
## YOUR CODE HERE

```

#### Solution Exercise 1 {#sec-solution-exercise-1 style="background-color: #e7fccc"}

```{r}
#| code-fold: true
#| output: true

ggplot(data = Table_TPMs_long_2, aes(x=Sample, y=TPMs))+
  geom_violin(color="darkblue", aes( fill=Replicate))



```

### 

### Overlapping layers

Because ggplots works with layers, we can also overlap different `geom_`
layers.

Here, will overlap scatter plot and box plot layers in 1 plot, and apply
following visual changes:

1- We will color the points by condition.

2- Fill boxes by replicate.

3- Hide the boxplot outlier dots.

4- Apply transparency (alpha) of 50% to all the boxplot layer.

```{r}
ggplot(data = Table_TPMs_long_2, aes(x=Sample, y=TPMs))+
  geom_point( position = position_jitter(), aes(color=Condition))+  # scatter plot, colored by
  geom_boxplot(outlier.colour ="darkred", aes(fill=Replicate), alpha=0.5, outlier.shape = NA)
```

#### Exercise 2 {style="background-color: #fafaa0"}

-   Make a boxplot layer colored by condition and replicate (you can use
    function `interaction()` when filling or coloring ).
-   Add a top layer with violin plots border in grey (filling
    transparent)

```{r}
## YOUR CODE HERE
```

#### Solution Exercise 2 {style="background-color: #e7fccc"}

```{r}
#| code-fold: true
#| output: true


ggplot(data = Table_TPMs_long_2, aes(x=Sample, y=TPMs))+
  geom_boxplot(aes(fill=interaction(Condition,Replicate)))+
  geom_violin( alpha=0, color="darkgrey")
```

### Density plot

Let's go back to a most basic chart structure. This time with a density
plot, of TPM distribution.

Note that all samples are merged in a single distribution.

```{r}
ggplot(data = Table_TPMs_long_2, aes(x=TPMs))+
  geom_density()
```

#### One curve per sample

In the mapping `aes()` we can indicate that data should be "group" by
"Sample", and will plot 1 line per sample.

Is worth noting that each `geom_` function has an internal "stat"option
that can perform operations in data, in this case, for example to
compute the kernel density.

```{r}
ggplot(data = Table_TPMs_long_2, aes(x=TPMs, group=Sample))+
  geom_density(stat = "density")
```

If instead of "group", we use "color", each line will get different
color.

Note that we can either put the group/fill in `aes()` in the main
`ggplot()`, as well as inside the `geom_` function. If applied at the
main `ggplo()` will apply to all layers unless specified differently,
other-ways applies to the specific layer only

```{r}
ggplot(data = Table_TPMs_long_2, aes(x=TPMs))+
  geom_density(aes(color=Sample)) # now color mapping is inside geom
```

```{r}
ggplot(data = Table_TPMs_long_2, aes(x=TPMs))+
  geom_dotplot(binwidth=15,aes(fill=Sample), alpha=0.7) # now color mapping is inside geom
```

## Barplots

For barplots, we use the function `geom_bar` . By default, geom bar
implements the function `stat=count`, and plots number of observations
for each X category. In this case, all samples ave 100 genes.

```{r}
 ggplot(data = Table_TPMs_long_2, aes(x=Sample))+
  geom_bar()# same as stat="count". 

```

As we mentioned, `geom_` can do some calculations. In this case, for
example, we want to calculate the mean of TPMs per sample, and plot it
as barplot.

```{r}
 ggplot(data = Table_TPMs_long_2, aes(x=Sample))+
  geom_bar(aes(y=TPMs),stat = "summary", fun = "mean")
```

Imagine we want to group the means by Replicate, and fill by condition.

```{r}
 ggplot(data = Table_TPMs_long_2, aes(x=Replicate, fill=Condition))+
  geom_bar(aes(y=TPMs),stat = "summary", fun = "mean")
```

Stack bars are difficult to interpret, we can change the position with
`position` function inside `geom_`.

```{r}
 ggplot(data = Table_TPMs_long_2, aes(x=Replicate, fill=Condition))+
  geom_bar(aes(y=TPMs),stat = "summary", fun = "mean", position = "dodge")
```

## Data manipulation before plotting

Instead of allowing ggplot to do calculation, is often more clear and
transparent (and help to avoid errors) to first calculate the numbers
ourselves and then use ggplot only for plotting. For that purpose, we
will need to define `stat="identity"` , to tell stat function to use a
given value and not attempt to calculate anything.

#### Exercise 3 {style="background-color: #fafaa0"}

1.  Calculate the mean TPMs per sample (tip: use dplyr functions).

2.  Plot the mean expression of TPMs per sample.

    a\. Fill bars by Condition.

```{r}
## YOUR CODE HERE

```

#### Solution Exercise 3 {#sec-solution-exercise style="background-color: #e7fccc"}

```{r}
#| code-fold: true
#| output: true

Sample_mean_TPMs<-Table_TPMs_long_2 %>% #  pipe concatenated commands (Ctrl+shift+M)
  group_by(Sample,Condition,Replicate) %>% # group data by sample
  summarise(meanTPMs=mean(TPMs)) # summarise would apply functions to each group and add it as new column

Sample_mean_TPMs
```

Now, to plot it, we will need to indicate `geom_bar()` that we don't
want to amply any calculation, just use the given values with
`stat="identity"`. This is the same as the new function `geom_col()`

```{r}
#| code-fold: true
#| output: true

ggplot(Sample_mean_TPMs, aes(x=Sample, y=meanTPMs))+
    geom_bar(stat="identity", aes(fill=Condition)) 

```

#### Geom col

-   To avoid confusions with the stat function of `geom_bar()` you can
    use `geom_col` which will not perform any stat function. Is
    equivalent to `stat="identity"`.

```{r}

ggplot(Sample_mean_TPMs, aes(x=Sample, y=meanTPMs))+
    geom_col( aes(fill=Condition)) 
```

## Concatenate dplyr and ggplots

Let's do more complicated computations, such as counting the proportion
of genes with \> 10 TPMs per sample.

-   Let's start creating contingency table, with the number of genes
    that \>10 TPMs in each condition. First we group with `group_by` and
    then with `summarise` we apply a function to count genes in each
    group with `n()` and we asign it to a new column called "Numgenes".

```{r}
Table_TPMs_long_2 %>%
    group_by(Sample, TPMs>10) %>%
   summarise(Numgenes=n())
```

Now I create a new column with `mutate` , in which I divide the
"Numgenes" by the `sum()` in each group (because we are still inside the
grouping effect),

```{r}
Table_TPMs_long_2 %>%
    group_by(Sample, TPMs>10) %>%
    summarise(Numgenes=n()) %>% 
    mutate(prop=Numgenes/sum(Numgenes))
```

We can pipe this firectly into ggplots

```{r}
Table_TPMs_long_2 %>%
    group_by(Sample, Condition, TPMs>10) %>%
    summarise(Numgenes=n()) %>% 
    mutate(proportion=Numgenes/sum(Numgenes)) %>% 
    filter(`TPMs > 10`==TRUE) %>% # I fitler only the rows that contain propof genes with >10TPMs   
        ggplot(aes(x=Sample, y=proportion))+# using ., ggplot will use as data what is piped to it
        geom_bar(stat="identity", aes(fill=Condition))
```

## Labels and annotation

As you know, it is important to label your axes!

To modify the default labels (based on your variable names), we can use
the `labs()` function,

```{r}
ggplot(data = Table_TPMs_long_2, aes(x=Sample, y=TPMs))+
  geom_boxplot( aes(fill=Condition))+
  labs(title="Here is the title", 
       subtitle="This is a subtitle", 
       x="X axis name", 
       y="Y axis name",
       caption = "I can also add caption ....")
```

## Facets

We might want to split our plot in multiple plots, for that purpose, we
can take advantage of `facet_wrap()` function, and split plots based on
any variable.

```{r}
ggplot(data = Table_TPMs_long_2, aes(x=Sample, y=TPMs))+
  geom_boxplot( aes(fill=Condition))+
  facet_wrap(~Condition, scales = "free_x") # facetting by Coniditon, allowing different x axis per plot
```

## Making plots aesthetic

### Themes

ggplot2 comes with a series of themes that make our lives easier. Here
are the list of basic themes
[here](https://ggplot2.tidyverse.org/reference/ggtheme.html). I am a
heavy user of `theme_minimal()` as starting point for my plots.

```{r}
ggplot(data = Table_TPMs_long_2, aes(x=Sample, y=TPMs))+
  geom_boxplot( aes(fill=Condition))+
  theme_minimal()
```

Additionally, you can install the package **ggthemes**, which omes with
many more themes (list
[here](https://yutannihilation.github.io/allYourFigureAreBelongToUs/ggthemes/)),
some of them following the styles of popular newspapers/platforms, such
as Wall Street Journal, the Economist, Tableau, Google Docs Charts, etc.

```{r}
library(ggthemes)
ggplot(data = Table_TPMs_long_2, aes(x=Sample, y=TPMs))+
  geom_boxplot( aes(fill=Condition))+
  theme_economist()+ scale_fill_economist()
  labs(title = "The Economist Theme")
```

### Color palettes

While default ggplot color palette is quite good for many purposes (and
themes often comes with color palettes too), we might want to use other
palettes.

We can load palettes such as **viridis** or **brewer** and call them
directly. Using `scale_fill_SCALE()` to map with "fill" parameter, or
`scale_color_SCALE()` to map to "color".

-   Here we use viridis
    [palette](https://ggplot2.tidyverse.org/reference/scale_viridis.html).
    Note we can specify palette color options such as, "viridis",
    "magma", "rocket", etc.

```{r}
library(viridis)

ggplot(data = Table_TPMs_long_2, aes(x=Sample, y=TPMs))+
  geom_boxplot( aes(fill=Condition))+
  theme_minimal()+
  scale_fill_viridis(discrete="TRUE", option = "viridis") # by daful things is continuous.
```

### Point Shapes

![](https://lh7-us.googleusercontent.com/wTmed0Wda3SRzkjzjxjLbMAwvKkKCx2D6NSifMtq91EYOPyr78yEy64r0Vj2jcCDLTmYAWoYkCY6RjIkuRV0-9Uys2Ttq4-hAcRDIpAIeAH3md5iMJgEx_Oqb93iwylXMAYD18y77mZE7ollhw7utugIWQ=s2048)

-   Shapes 0 to 14 are **outline only**: color to change colors.

-   Shapes 15 to 20 are **fill only**: color to change colors.

-   Shapes 21 to 25 are **outline + fill**: use color to for outline and
    fill for filling.

## Saving plots

#### Exercise 4 {style="background-color: #fafaa0"}

For a research paper, we want to plot the expression of the genes with
\>900 TPMs within all controls or within all treated samples (tip: sum
in each group).

For each gene, we want to have it's own plot (tip: facet).

Make a "publication quality" plot take care of labels, shapes, colors,
resolution etc. The figure should be the with of the page (2 column =
\~13 cm),

Export it in svg and png.

```{r}
## YOUR CODE HERE

```

#### Solution Exercise 4 {style="background-color: #e7fccc"}

```{r}
#| code-fold: true
#| output: true

Selected_gene_IDs<-Table_TPMs_long_2 %>% 
  group_by(GeneID,Condition) %>% 
  mutate(sumtpms=sum(TPMs)) %>% 
  filter(sumtpms>900) %>% 
  ungroup() %>% 
  select(GeneID) %>% 
  distinct()

Selected_gene_IDs

```

```{r}
Table_TPMs_for_plot<-Table_TPMs_long_2 %>% 
  filter(GeneID %in% Selected_gene_IDs$GeneID)

Table_TPMs_for_plot
```

```{r}
#| code-fold: false

Plot_genes_900tpms<-ggplot(Table_TPMs_for_plot, aes(x=Condition, y=TPMs))+
  geom_point(stat = "identity", position = position_jitter(), aes(fill=Condition), pch=21, color="black", size=2) +
  scale_fill_brewer(palette="Set2")+
  facet_wrap(~GeneID, ncol = 4 )+
  theme_minimal(base_size = 8)+ # base font size 8 points
  labs(Title="Expressio of highly expressed genes",
       subtitle="Genes with >900 TPMs within control or treated condition",
       y="Gene expression (TPMs)", )

Plot_genes_900tpms
```

```{r}
#| warning: false

#ggsave("images/Plot_genes_900tpms.png", Plot_genes_900tpms, width = 13, height = 10, units= "cm", dpi =300,   scale = 1)

#ggsave("images/Plot_genes_900tpms.svg", Plot_genes_900tpms, width = 13, height = 10, units= "cm")

```

## More examples

### Linear Model Fit

Let's load the iris dataset.

```{r}
data(iris)
```

Here, we can even compute a linear model with `lm()` inside a
`geom_smooth()` function.

```{r}
ggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) + 
  geom_point() +
  geom_smooth(method = "lm")+
  theme_minimal()
```

### 

# Plotly

We can combine gplots and plotly to create interactive plots with
`ggplotly()`!

```{r}
#| warning: false 
  
library(plotly)


MyGgpot<-ggplot(data = Table_TPMs_long_2, aes(x=Sample, y=TPMs))+
  geom_boxplot( aes(fill=Condition))+
  theme_minimal()+
  scale_fill_viridis(discrete="TRUE", option = "viridis") # by daful things is continuous.

ggplotly(MyGgpot)

```

```{r}
My_ggplot_lm<-ggplot(data = iris, aes(x = Petal.Length, y = Sepal.Length)) + 
  geom_point() +
  geom_smooth(method = "lm")+
  theme_minimal()


ggplotly(My_ggplot_lm)
```

# Recommended bibliography

-   **Book:** Data Visualization: A Practical Introduction. Auhtor:
    Kieran Healy
